#include <iostream>
#include <filesystem>
#include <fstream>

#include <memory>
#include <vector>

#include <Windows.h>

/*
 *	GOAL: Read the first instruction that program will execute
 *	Optional Header -> AddressOfEntryPoint (Relative Virtual Address)
 *	RVA + ImageBase = Absolute Virtual Address
 *	AddressOfEntryPoint MUST exist in some section
 *
 *	Look at section headers
 *		Name
 *		VirtualAddress (RVA, where it's loaded at runtime relative to ImageBase)
 *		RawAddress (Physical Location in file)
 *
 *	_VirtualAddress = Start RVA + ImageBase
 *
 *	VirtualAddressOfEntryPoint = AddressOfEntryPoint + ImageBase
 *	Find out which section that's in (look at StartVA)
 *
 *
 *	THEN
 *
 *	Convert the address to an offset into the section
 *
 *	THEN
 *
 *	Add offset to start of the section on the disk
 */

std::shared_ptr<IMAGE_SECTION_HEADER> getSection(const std::vector<std::shared_ptr<IMAGE_SECTION_HEADER>>& sectionHeaders, unsigned long imageBase, unsigned long virtualAddress) {
	// Error message for not even being in first section
	if (sectionHeaders.at(0)->VirtualAddress + imageBase > virtualAddress) throw new std::exception();

	// Make sure at least 2 sections
	size_t returnIndex = 0;
	for (size_t index = 1; index < sectionHeaders.size(); index++) {
		if (sectionHeaders.at(index)->VirtualAddress + imageBase > virtualAddress) break;

		returnIndex = index;
	}

	// How to make sure it's really in the last one if we think it is?
	return sectionHeaders.at(returnIndex);
}

int main(int argc, char** argv) {
	std::filesystem::path fileLocation = "C:/Users/avery/Documents/MalwareAnalysis/vapid/sample.exe";// argv[1];
	if (!std::filesystem::exists(fileLocation)) return 1;

	std::string hexString = "0x4c5002"; // argv[2];
	long targetVirtualAddress = strtol(hexString.c_str(), NULL, 0);

	// Allocate space to store dosHeader and ntHeader
	auto dosHeader = std::make_shared<IMAGE_DOS_HEADER>();
	auto ntHeader = std::make_shared<IMAGE_NT_HEADERS32>();

	// Open file
	std::ifstream inputFile(fileLocation.c_str(), std::ios::in | std::ios::binary);
	if (!inputFile) {
		std::cout << "Couldn't open" << std::endl; return 1;
	}
	else {
		std::cout << "Opened file!" << std::endl;
	}

	// Read first 64 bytes of the file as the dosHeader
	inputFile.read((char*)dosHeader.get(), sizeof(IMAGE_DOS_HEADER));
	if (!inputFile || (dosHeader->e_magic != 0x5A4D)) return 1;

	std::cout << "Valid e_magic!" << std::endl;

	// Use e_lfanew to move to the NT Header
	inputFile.seekg(dosHeader->e_lfanew);

	// Starting at offset of e_lfanew, read the next 248 bytes as the ntHeader
	inputFile.read((char*)ntHeader.get(), sizeof(IMAGE_NT_HEADERS32));
	if (!inputFile || (ntHeader->Signature != 0x00004550)) return 1;

	// Get the File Header and Optional Header from the NT Header
	auto fileHeader = std::make_shared<IMAGE_FILE_HEADER>(ntHeader->FileHeader);
	auto optionalHeader = std::make_shared<IMAGE_OPTIONAL_HEADER32>(ntHeader->OptionalHeader);

	// Create a vector to store each Section Header 
	std::vector<std::shared_ptr<IMAGE_SECTION_HEADER>> sectionHeaders(fileHeader->NumberOfSections);
	for (int sectionIndex = 0; sectionIndex < fileHeader->NumberOfSections; sectionIndex++) {
		// Create space to read header into
		auto temp = std::make_shared<IMAGE_SECTION_HEADER>();
		// Read header into temp value, then move ownership to the vector
		inputFile.read((char*)temp.get(), sizeof(IMAGE_SECTION_HEADER));
		sectionHeaders.at(sectionIndex) = std::move(temp);
	}

	unsigned long imageBase = optionalHeader->ImageBase;

	unsigned long virtualAddress = targetVirtualAddress + imageBase;
	std::shared_ptr<IMAGE_SECTION_HEADER> containingSection = getSection(sectionHeaders, imageBase, virtualAddress);

	unsigned long sectionOffset = virtualAddress - (containingSection->VirtualAddress - imageBase);

	unsigned long physicalAddress = containingSection->PointerToRawData + sectionOffset;
	std::cout << std::hex << physicalAddress << std::endl;

	return 0;
}
