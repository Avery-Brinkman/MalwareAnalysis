#include <iostream>
#include <filesystem>
#include <fstream>

#include <memory>
#include <vector>

#include <Windows.h>

/*
 *	GOAL: Read the first instruction that program will execute
 *	Optional Header -> AddressOfEntryPoint (Relative Virtual Address)
 *	RVA + ImageBase = Absolute Virtual Address
 *	AddressOfEntryPoint MUST exist in some section
 *
 *	Look at section headers
 *		Name
 *		VirtualAddress (RVA, where it's loaded at runtime relative to ImageBase)
 *		RawAddress (Physical Location in file)
 *
 *	_VirtualAddress = Start RVA + ImageBase
 *
 *	VirtualAddressOfEntryPoint = AddressOfEntryPoint + ImageBase
 *	Find out which section that's in (look at StartVA)
 *
 *
 *	THEN
 *
 *	Convert the address to an offset into the section
 *
 *	THEN
 *
 *	Add offset to start of the section on the disk
 */

std::shared_ptr<IMAGE_SECTION_HEADER> getSection(const std::vector<std::shared_ptr<IMAGE_SECTION_HEADER>>& sectionHeaders, DWORD imageBase, DWORD virtualAddress) {
	// Error message for not even being in first section
	if (sectionHeaders.at(0)->VirtualAddress + imageBase > virtualAddress) throw new std::exception();

	for (size_t index = 0; index < sectionHeaders.size(); index++) {
		DWORD sectionVirtualAddress = sectionHeaders.at(index)->VirtualAddress + imageBase;
		DWORD sectionVirtualAddress_end = sectionVirtualAddress + sectionHeaders.at(index)->Misc.VirtualSize;

		if ((sectionVirtualAddress < virtualAddress) && (sectionVirtualAddress_end > virtualAddress))
			return sectionHeaders.at(index);
	}

	throw new std::exception();
}

int main(int argc, char** argv) {
	std::filesystem::path fileLocation = argv[1];
	if (!std::filesystem::exists(fileLocation)) return 1;

	std::string hexString = argv[2];
	DWORD relativeVirtualAddress = strtol(hexString.c_str(), NULL, 0);

	// Allocate space to store dosHeader and ntHeader
	auto dosHeader = std::make_shared<IMAGE_DOS_HEADER>();
	auto ntHeader = std::make_shared<IMAGE_NT_HEADERS32>();

	// Open file
	std::ifstream inputFile(fileLocation.c_str(), std::ios::in | std::ios::binary);
	if (!inputFile) {
		std::cout << "Couldn't open" << std::endl;
		return 1;
	}
	std::cout << "Opened file" << std::endl;

	// Read first 64 bytes of the file as the dosHeader
	inputFile.read((char*)dosHeader.get(), sizeof(IMAGE_DOS_HEADER));
	if (!inputFile || (dosHeader->e_magic != 0x5A4D)) {
		std::cout << "Could not read DOS Header" << std::endl;
		return 1;
	}
	std::cout << "Read DOS Header" << std::endl;


	// Use e_lfanew to move to the NT Header
	inputFile.seekg(dosHeader->e_lfanew);

	// Starting at offset of e_lfanew, read the next bytes as the NT Header
	inputFile.read((char*)ntHeader.get(), sizeof(IMAGE_NT_HEADERS32));
	if (!inputFile || (ntHeader->Signature != 0x00004550)) {
		std::cout << "Could not read signature" << std::endl;
		return 1;
	}
	std::cout << "Read signature" << std::endl;

	// Get the File Header
	auto fileHeader = std::make_shared<IMAGE_FILE_HEADER>(ntHeader->FileHeader);
	std::cout << "Read File Header" << std::endl;

	// Get the Optional Header
	auto optionalHeader = std::make_shared<IMAGE_OPTIONAL_HEADER32>(ntHeader->OptionalHeader);
	std::cout << "Read Optional Header" << std::endl;

	// Create a vector to store each Section Header 
	std::vector<std::shared_ptr<IMAGE_SECTION_HEADER>> sectionHeaders;
	for (int sectionIndex = 0; sectionIndex < fileHeader->NumberOfSections; sectionIndex++) {
		// Read header into the vector
		auto currentSectionHeader = std::make_shared<IMAGE_SECTION_HEADER>();
		inputFile.read((char*)currentSectionHeader.get(), sizeof(IMAGE_SECTION_HEADER));
		sectionHeaders.push_back(currentSectionHeader);
	}
	std::cout << "Read Section Headers" << std::endl;

	DWORD imageBase = optionalHeader->ImageBase;

	// DWORD absoluteVirtualAddress = relativeVirtualAddress + imageBase;
	std::shared_ptr<IMAGE_SECTION_HEADER> containingSection = getSection(sectionHeaders, imageBase, relativeVirtualAddress);

	DWORD sectionOffset = relativeVirtualAddress - (containingSection->VirtualAddress + imageBase);

	DWORD physicalAddress = containingSection->PointerToRawData + sectionOffset;
	std::cout << "0x" << std::hex << physicalAddress << std::endl;

	return 0;
}
