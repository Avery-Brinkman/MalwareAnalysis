#include <iostream>
#include <filesystem>
#include <fstream>

#include <memory>
#include <vector>

#include <Windows.h>

/*
 *	GOAL: Read the first instruction that program will execute
 *	Optional Header -> AddressOfEntryPoint (Relative Virtual Address)
 *	RVA + ImageBase = Absolute Virtual Address
 *	AddressOfEntryPoint MUST exist in some section
 *
 *	Look at section headers
 *		Name
 *		VirtualAddress (RVA, where it's loaded at runtime relative to ImageBase)
 *		RawAddress (Physical Location in file)
 *
 *	_VirtualAddress = Start RVA + ImageBase
 *
 *	VirtualAddressOfEntryPoint = AddressOfEntryPoint + ImageBase
 *	Find out which section that's in (look at StartVA)
 *
 *
 *	THEN
 *
 *	Convert the address to an offset into the section
 *
 *	THEN
 *
 *	Add offset to start of the section on the disk
 */

 /*
 */
std::shared_ptr<IMAGE_SECTION_HEADER> getSection(
	const std::vector<std::shared_ptr<IMAGE_SECTION_HEADER>>& sectionHeaders,
	DWORD imageBase, DWORD virtualAddress) {

	// For formatting
	std::stringstream strStream;

	// Error message for not even being in first section
	if (sectionHeaders.at(0)->VirtualAddress + imageBase > virtualAddress) {
		// Formatting
		strStream << std::hex << virtualAddress;
		std::string given = strStream.str();
		strStream.str("");
		strStream << std::hex << sectionHeaders.at(0)->VirtualAddress + imageBase;
		std::string first = strStream.str();

		throw std::range_error("Address 0x" + given + " begins before the start of the first section (0x" + first + ")");
	}

	for (size_t index = 0; index < sectionHeaders.size(); index++) {
		// Get the start and end Absolute Virtual Addresses for the current section
		DWORD sectionVA_start = sectionHeaders.at(index)->VirtualAddress + imageBase;
		DWORD sectionVA_end = sectionVA_start + sectionHeaders.at(index)->Misc.VirtualSize;

		// Check if our given address exists within this section, and return it if it does
		if ((sectionVA_start < virtualAddress) && (sectionVA_end > virtualAddress))
			return sectionHeaders.at(index);
	}

	// Formatting stuff
	strStream << std::hex << virtualAddress;

	throw std::range_error("None of the provided sections contain the address 0x" + strStream.str());
}

int main(int argc, char** argv) {
	std::filesystem::path fileLocation = "C:/Users/avery/Documents/MalwareAnalysis/vapid/sample.exe"; // argv[1];
	if (!std::filesystem::exists(fileLocation)) {
		std::cout << "No file exists at " << fileLocation << std::endl;
		return 1;
	}

	std::string hexString = "0x40000000000002"; // argv[2];
	DWORD relativeVirtualAddress = strtoul(hexString.c_str(), NULL, 0);

	// Allocate space to store dosHeader and ntHeader
	auto dosHeader = std::make_shared<IMAGE_DOS_HEADER>();
	auto ntHeader = std::make_shared<IMAGE_NT_HEADERS32>();

	// Open file
	std::ifstream inputFile(fileLocation.c_str(), std::ios::in | std::ios::binary);
	if (!inputFile) {
		std::cout << "Could not open file at " << fileLocation << std::endl;
		return 1;
	}

	// Read first 64 bytes of the file as the dosHeader
	inputFile.read((char*)dosHeader.get(), sizeof(IMAGE_DOS_HEADER));
	if (!inputFile || (dosHeader->e_magic != 0x5A4D)) {
		std::cout << "Could not read DOS Header" << std::endl;
		return 1;
	}

	// Use e_lfanew to move to the NT Header
	inputFile.seekg(dosHeader->e_lfanew);

	// Starting at offset of e_lfanew, read the next bytes as the NT Header
	inputFile.read((char*)ntHeader.get(), sizeof(IMAGE_NT_HEADERS32));
	// Ensure successful read and that Signature is set to 'PE\0\0'
	if (!inputFile || (ntHeader->Signature != 0x00004550)) {
		std::cout << "Could not read NT Header" << std::endl;
		return 1;
	}

	// Get the File Header from the NT Header
	auto fileHeader = std::make_shared<IMAGE_FILE_HEADER>(ntHeader->FileHeader);

	// Get the Optional Header
	auto optionalHeader = std::make_shared<IMAGE_OPTIONAL_HEADER32>(ntHeader->OptionalHeader);

	// Make sure that the Optional Header is the correct size
	if (sizeof(optionalHeader.get()) != fileHeader->SizeOfOptionalHeader) {
		std::cout << "Expected Optional Header Size to be " <<
			fileHeader->SizeOfOptionalHeader << " bytes long, got "
			<< sizeof(optionalHeader.get()) << " bytes" << std::endl;
		return 1;
	}

	// Create a vector to store each Section Header 
	std::vector<std::shared_ptr<IMAGE_SECTION_HEADER>> sectionHeaders;
	for (int sectionIndex = 0; sectionIndex < fileHeader->NumberOfSections; sectionIndex++) {
		// Read header into the vector
		auto currentSectionHeader = std::make_shared<IMAGE_SECTION_HEADER>();
		inputFile.read((char*)currentSectionHeader.get(), sizeof(IMAGE_SECTION_HEADER));
		sectionHeaders.push_back(currentSectionHeader);
	}

	// Get the Image Base
	DWORD imageBase = optionalHeader->ImageBase;

	// Try and get the section that contains the given address
	std::shared_ptr<IMAGE_SECTION_HEADER> containingSection;
	try {
		containingSection = getSection(sectionHeaders, imageBase, relativeVirtualAddress);
	}
	catch (const std::range_error& err) {
		std::cout << err.what() << std::endl;
		std::cout << std::hex << "0x" << relativeVirtualAddress << " -> ??" << std::endl;
		return 1;
	}

	// Find the offset of the given address in the section it's contained in
	DWORD sectionOffset = relativeVirtualAddress - (containingSection->VirtualAddress + imageBase);

	// Find physical address of the given address
	DWORD physicalAddress = containingSection->PointerToRawData + sectionOffset;

	// Display results
	std::cout << std::hex << "0x" << relativeVirtualAddress << " -> 0x" << physicalAddress << std::endl;
	return 0;
}
