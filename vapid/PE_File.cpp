#include "PE_File.h"
#include <iostream>
#include <sstream>

using namespace PE_FILE_NS;

PEFile::PEFile(const std::string_view fileName) {
  // Open file
  std::ifstream fileHandle(fileName.data(), std::ios::in | std::ios::binary);
  if (!fileHandle)
    throw std::invalid_argument("Could not open file at " + std::string(fileName.data()));

  // Allocate space for member vars
  m_dosHeader = std::make_shared<IMAGE_DOS_HEADER>();
  m_ntHeader = std::make_shared<IMAGE_NT_HEADERS32>();

  // Read first 64 bytes of the file as the dosHeader
  fileHandle.read((char*)m_dosHeader.get(), sizeof(IMAGE_DOS_HEADER));
  // Ensure header was read and that e_magic contains 'MZ'
  if (!fileHandle || (m_dosHeader->e_magic != MAGIC))
    throw std::runtime_error("Could not read DOS Header");

  // Move to the location of NT Header
  fileHandle.seekg(m_dosHeader->e_lfanew);

  // Starting at offset of e_lfanew, read the next bytes as the NT Header
  fileHandle.read((char*)m_ntHeader.get(), sizeof(IMAGE_NT_HEADERS32));
  // Ensure successful read and that Signature is set to 'PE\0\0'
  if (!fileHandle || (m_ntHeader->Signature != SIG))
    throw std::runtime_error("Could not read NT Header");

  // Get the File Header and Optional Header from the NT Header
  m_fileHeader = std::make_shared<IMAGE_FILE_HEADER>(m_ntHeader->FileHeader);
  m_optionalHeader = std::make_shared<IMAGE_OPTIONAL_HEADER32>(m_ntHeader->OptionalHeader);

  // Set the Image Base
  m_imageBase = m_optionalHeader->ImageBase;

  // Store each Section Header
  for (int sectionIndex = 0; sectionIndex < m_fileHeader->NumberOfSections; sectionIndex++) {
    // Read header into the vector
    auto currentSectionHeader = std::make_shared<IMAGE_SECTION_HEADER>();
    fileHandle.read((char*)currentSectionHeader.get(), sizeof(IMAGE_SECTION_HEADER));
    m_sectionHeaders.push_back(currentSectionHeader);
  }
}

std::shared_ptr<IMAGE_SECTION_HEADER> PEFile::getSection(const DWORD virtualAddress) {
  // For formatting
  std::stringstream strStream;

  // Error message for not even being in first section
  if (m_sectionHeaders.at(0)->VirtualAddress + m_imageBase > virtualAddress) {
    // Formatting
    strStream << std::hex << virtualAddress;
    std::string given = strStream.str();
    strStream.str("");
    strStream << std::hex << m_sectionHeaders.at(0)->VirtualAddress + m_imageBase;
    std::string first = strStream.str();

    throw std::range_error("Address 0x" + given +
                           " begins before the start of the first section (0x" + first + ")");
  }

  for (size_t index = 0; index < m_sectionHeaders.size(); index++) {
    // Get the start and end Absolute Virtual Addresses for the current section
    DWORD sectionVA_start = m_sectionHeaders.at(index)->VirtualAddress + m_imageBase;
    DWORD sectionVA_end = sectionVA_start + m_sectionHeaders.at(index)->Misc.VirtualSize;

    // Check if our given address exists within this section, and return it if it does
    if ((sectionVA_start < virtualAddress) && (sectionVA_end > virtualAddress))
      return m_sectionHeaders.at(index);
  }

  // Section should've been returned by now, so throw error
  // Formatting stuff
  strStream << std::hex << virtualAddress;
  throw std::range_error("None of the provided sections contain the address 0x" + strStream.str());
}

DWORD PEFile::getPhysicalAddress(const DWORD virtualAddress) {
  // Find the section that the given address is contained in
  auto containingSection = this->getSection(virtualAddress);

  // Find the offset of the given address in the section it's contained in
  DWORD sectionOffset = virtualAddress - (containingSection->VirtualAddress + m_imageBase);

  // Find physical address of the given address
  DWORD physicalAddress = containingSection->PointerToRawData + sectionOffset;

  return physicalAddress;
}
